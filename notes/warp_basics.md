# Warp Basics: Compilation and IR

## Kernel Compilation Flow
1. **Parsing**: When `@wp.kernel` decorates a function, `warp.context.Function` (and `Kernel`) parses the Python source using `ast`.
2. **Analysis**: `warp.codegen.Adjoint` analyzes the AST, performs type inference, and converts it into an internal SSA-like representation (stored in `Adjoint.blocks`).
3. **Module Build**: `warp.context.ModuleBuilder` collects all kernels and dependencies (functions, structs) for a module. It computes hashes to ensure uniqueness.
4. **Codegen**: `warp.codegen` generates C++ (CPU) or CUDA (GPU) source code from the `Adjoint` representation.
5. **Compilation**: The generated source is compiled using a backend compiler (nvcc or clang/gcc) into a shared library (`.so` or `.dll`).
6. **Loading**: The shared library is loaded and kernel hooks are registered for execution.

## Intermediate Representation (IR)
Warp does not expose a standalone structured IR like LLVM IR. Instead, the "IR" acts at two levels:
1. **AST/SSA**: The `Adjoint` class holds the Python AST and a list of basic blocks with variables and operations. This is the primary internal representation.
2. **Generated Source**: The C++/CUDA code generated by `codegen_kernel` serves as the low-level representation that is actually compiled.

For the purpose of training data synthesis, the **Generated C++/CUDA Source** is the most relevant "IR" as it represents the fully typed, lowered logic of the kernel.

## Extraction Mechanism
To extract the IR (C++ source) for a given kernel:
1. Ensure the kernel's module is built (or at least analyzed) using `ModuleBuilder.build_kernel(kernel)`.
2. Call `warp.codegen.codegen_kernel(kernel, device=..., options=...)`.
3. This returns the C++ source string containing the forward and backward (adjoint) passes.
