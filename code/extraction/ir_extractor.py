"""
IR Extractor for Warp Kernels

This module provides functionality to extract the intermediate representation
(C++ code) generated by Warp's JIT compiler from Python kernels.

Usage:
    from extraction.ir_extractor import extract_ir, extract_ir_to_file
    
    @wp.kernel
    def my_kernel(...):
        ...
    
    # Extract IR as string
    cpp_code = extract_ir(my_kernel)
    
    # Save to file with metadata
    extract_ir_to_file(my_kernel, "output_dir/")
"""

import warp as wp
import os
import json
from typing import Optional, Dict, Any
from dataclasses import dataclass, asdict


@dataclass
class IRExtractionResult:
    """Container for IR extraction results."""
    kernel_name: str
    module_name: str
    module_hash: str
    device: str
    cpp_source: str
    python_source: str
    cache_path: str
    success: bool
    error_message: Optional[str] = None


def extract_ir(kernel, device: str = "cpu", force_compile: bool = True) -> IRExtractionResult:
    """
    Extract the C++ intermediate representation from a Warp kernel.
    
    Args:
        kernel: A Warp kernel object (decorated with @wp.kernel)
        device: Target device for compilation ("cpu" or "cuda")
        force_compile: If True, ensures kernel is compiled before extraction
        
    Returns:
        IRExtractionResult containing the extracted C++ code and metadata
    """
    try:
        # Get the module containing this kernel
        module = kernel.module
        
        if force_compile:
            # Force compilation by loading the module on the target device
            module.load(device)
        
        # Get kernel cache directory
        cache_dir = wp.config.kernel_cache_dir
        
        # Module naming: wp_{module_name}_{hash}
        module_name_safe = module.name.replace(".", "_")
        
        # Find the module directory in cache
        cache_contents = os.listdir(cache_dir)
        prefix = f"wp_{module_name_safe}_"
        
        matching_dirs = [d for d in cache_contents if d.startswith(prefix)]
        
        if not matching_dirs:
            return IRExtractionResult(
                kernel_name=kernel.key,
                module_name=module.name,
                module_hash="unknown",
                device=device,
                cpp_source="",
                python_source="",
                cache_path="",
                success=False,
                error_message=f"No cached module found with prefix: {prefix}"
            )
        
        # Use the first match (should be only one for a given module state)
        module_dir = matching_dirs[0]
        module_path = os.path.join(cache_dir, module_dir)
        
        # Extract hash from directory name
        module_hash = module_dir[len(prefix):]
        
        # Look for the .cpp file
        cpp_file = os.path.join(module_path, f"{module_dir}.cpp")
        
        if not os.path.exists(cpp_file):
            return IRExtractionResult(
                kernel_name=kernel.key,
                module_name=module.name,
                module_hash=module_hash,
                device=device,
                cpp_source="",
                python_source="",
                cache_path=module_path,
                success=False,
                error_message=f"C++ file not found: {cpp_file}"
            )
        
        # Read the C++ source
        with open(cpp_file, 'r') as f:
            cpp_source = f.read()
        
        # Get Python source from kernel's adjoint
        python_source = kernel.adj.source if hasattr(kernel, 'adj') else ""
        
        return IRExtractionResult(
            kernel_name=kernel.key,
            module_name=module.name,
            module_hash=module_hash,
            device=device,
            cpp_source=cpp_source,
            python_source=python_source,
            cache_path=module_path,
            success=True
        )
        
    except Exception as e:
        return IRExtractionResult(
            kernel_name=getattr(kernel, 'key', 'unknown'),
            module_name=getattr(kernel.module, 'name', 'unknown') if hasattr(kernel, 'module') else 'unknown',
            module_hash="unknown",
            device=device,
            cpp_source="",
            python_source="",
            cache_path="",
            success=False,
            error_message=f"Extraction failed: {str(e)}"
        )


def extract_ir_to_file(kernel, output_dir: str, device: str = "cpu", 
                       include_metadata: bool = True) -> bool:
    """
    Extract IR and save to files in the specified directory.
    
    Creates:
        - {kernel_name}.cpp: The extracted C++ IR
        - {kernel_name}.py: The Python source
        - {kernel_name}.json: Metadata about the extraction
    
    Args:
        kernel: A Warp kernel object
        output_dir: Directory to save files to
        device: Target device
        include_metadata: Whether to save metadata JSON
        
    Returns:
        True if successful, False otherwise
    """
    os.makedirs(output_dir, exist_ok=True)
    
    result = extract_ir(kernel, device)
    
    if not result.success:
        print(f"Extraction failed: {result.error_message}")
        return False
    
    # Create safe filename from kernel name
    safe_name = result.kernel_name.replace(".", "_").replace("/", "_")
    
    # Save C++ IR
    cpp_path = os.path.join(output_dir, f"{safe_name}.cpp")
    with open(cpp_path, 'w') as f:
        f.write(result.cpp_source)
    
    # Save Python source
    py_path = os.path.join(output_dir, f"{safe_name}.py")
    with open(py_path, 'w') as f:
        f.write(result.python_source)
    
    # Save metadata
    if include_metadata:
        metadata = {
            "kernel_name": result.kernel_name,
            "module_name": result.module_name,
            "module_hash": result.module_hash,
            "device": result.device,
            "cache_path": result.cache_path,
            "cpp_file": cpp_path,
            "py_file": py_path
        }
        
        meta_path = os.path.join(output_dir, f"{safe_name}.json")
        with open(meta_path, 'w') as f:
            json.dump(metadata, f, indent=2)
    
    print(f"âœ“ Extracted IR for {result.kernel_name}")
    print(f"  C++:  {cpp_path}")
    print(f"  Python: {py_path}")
    if include_metadata:
        print(f"  Metadata: {meta_path}")
    
    return True


def extract_multiple(kernels: list, output_dir: str, device: str = "cpu") -> Dict[str, bool]:
    """
    Extract IR from multiple kernels.
    
    Args:
        kernels: List of Warp kernel objects
        output_dir: Directory to save all extractions
        device: Target device
        
    Returns:
        Dictionary mapping kernel names to success status
    """
    results = {}
    
    for kernel in kernels:
        kernel_name = kernel.key
        success = extract_ir_to_file(kernel, output_dir, device)
        results[kernel_name] = success
    
    return results
