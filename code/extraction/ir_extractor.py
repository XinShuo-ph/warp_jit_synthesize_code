"""IR Extraction Utility for Warp Kernels.

This module provides functions to extract the intermediate representation (IR)
generated by Warp's JIT compiler from Python kernel functions.

API Design:
-----------
extract_ir(kernel) -> dict
    Extract both Python source and generated C++ IR from a warp kernel.
    
    Args:
        kernel: A warp.Kernel object (created via @wp.kernel decorator)
    
    Returns:
        dict with keys:
            - 'python_source': Original Python function source code
            - 'cpp_ir': Generated C++ intermediate representation
            - 'kernel_name': Name of the kernel function
            - 'module_name': Name of the module
            - 'hash': Module hash identifier
            - 'cache_path': Path to cached C++ file
            - 'signature': Function signature information
"""

import warp as wp
import inspect
import os
import glob
from typing import Dict, Any


def _trigger_compilation(kernel: wp.Kernel) -> None:
    """Trigger kernel compilation by launching with dummy data.
    
    This is necessary because Warp uses lazy compilation - the IR is only
    generated when the kernel is first executed.
    
    Args:
        kernel: Warp kernel to compile
    """
    # Inspect kernel signature to create appropriate dummy inputs
    sig = inspect.signature(kernel.func)
    
    dummy_inputs = []
    for param_name, param in sig.parameters.items():
        # Check if it's an array type
        if hasattr(param.annotation, '__origin__'):
            # It's a wp.array - create a dummy array
            dtype = float  # Default to float
            if hasattr(param.annotation, '__args__'):
                # Try to extract dtype if specified
                pass
            dummy_inputs.append(wp.zeros(1, dtype=dtype))
    
    # Launch with minimal data to trigger compilation
    try:
        wp.launch(kernel, dim=1, inputs=dummy_inputs, device='cpu')
        wp.synchronize()
    except Exception as e:
        # Even if launch fails, compilation might have been triggered
        pass


def _find_cache_file(module_name: str, cache_dir: str) -> str:
    """Find the most recent cache file for a module.
    
    Args:
        module_name: Name of the warp module (e.g., '__main__' or 'synthesis.generator')
        cache_dir: Warp cache directory path
    
    Returns:
        Path to the .cpp file, or None if not found
    """
    if not cache_dir or not os.path.exists(cache_dir):
        return None
    
    # Module names are used as-is in the cache directory name (dots are kept)
    pattern = f"wp_{module_name}_*"
    
    # Find all matching module directories
    module_dirs = glob.glob(os.path.join(cache_dir, pattern))
    
    if not module_dirs:
        return None
    
    # Get the most recently modified directory
    latest_dir = max(module_dirs, key=os.path.getmtime)
    
    # Find the .cpp file in that directory
    cpp_files = glob.glob(os.path.join(latest_dir, "*.cpp"))
    
    return cpp_files[0] if cpp_files else None


def _extract_kernel_from_cpp(cpp_content: str, kernel_name: str) -> str:
    """Extract the specific kernel function from the full C++ file.
    
    Args:
        cpp_content: Full C++ file content
        kernel_name: Name of the kernel to extract (can be partial match)
    
    Returns:
        The kernel function code (forward pass)
    """
    # Look for the forward kernel function
    # The actual function name in C++ might include module path and hash
    # Format: void ..._cpu_kernel_forward(
    lines = cpp_content.split('\n')
    
    kernel_lines = []
    in_kernel = False
    brace_count = 0
    
    for line in lines:
        # Start capturing when we find ANY kernel forward function
        # (since there should only be one per file in our case)
        if '_cpu_kernel_forward' in line and 'void ' in line:
            in_kernel = True
        
        if in_kernel:
            kernel_lines.append(line)
            
            # Count braces to know when function ends
            brace_count += line.count('{')
            brace_count -= line.count('}')
            
            # If we've closed all braces, we're done
            if brace_count == 0 and '{' in ''.join(kernel_lines):
                break
    
    return '\n'.join(kernel_lines)


def extract_ir(kernel: wp.Kernel, trigger_compile: bool = True) -> Dict[str, Any]:
    """Extract Python source and C++ IR from a Warp kernel.
    
    Args:
        kernel: A warp.Kernel object (created via @wp.kernel decorator)
        trigger_compile: Whether to trigger compilation if not already compiled
    
    Returns:
        Dictionary containing:
            - python_source: Original Python source code
            - cpp_ir: Generated C++ IR (full file)
            - cpp_kernel: Extracted kernel function only
            - kernel_name: Kernel function name
            - module_name: Module name
            - cache_path: Path to cached C++ file
            - signature: Function signature as string
    """
    # Get Python source
    python_source = inspect.getsource(kernel.func)
    
    # Get kernel metadata
    kernel_name = kernel.func.__name__
    module_name = kernel.module.name
    
    # Get function signature
    sig = inspect.signature(kernel.func)
    signature = f"{kernel_name}{sig}"
    
    # Trigger compilation if requested
    if trigger_compile:
        # Check if already compiled by looking for cache file
        cache_dir = wp.config.kernel_cache_dir
        cache_file = _find_cache_file(module_name, cache_dir)
        
        if not cache_file:
            _trigger_compilation(kernel)
            # Re-check for cache file
            cache_file = _find_cache_file(module_name, cache_dir)
    else:
        cache_dir = wp.config.kernel_cache_dir
        cache_file = _find_cache_file(module_name, cache_dir)
    
    # Read C++ IR from cache
    cpp_ir = None
    cpp_kernel = None
    
    if cache_file and os.path.exists(cache_file):
        with open(cache_file, 'r') as f:
            cpp_ir = f.read()
        
        # Extract just the kernel function
        cpp_kernel = _extract_kernel_from_cpp(cpp_ir, kernel_name)
    
    return {
        'python_source': python_source,
        'cpp_ir': cpp_ir,
        'cpp_kernel': cpp_kernel,
        'kernel_name': kernel_name,
        'module_name': module_name,
        'cache_path': cache_file,
        'signature': signature,
    }


def extract_ir_pair(kernel: wp.Kernel) -> tuple[str, str]:
    """Extract just the Python source and C++ kernel function.
    
    Convenience function for getting the training data pair.
    
    Args:
        kernel: Warp kernel object
    
    Returns:
        Tuple of (python_source, cpp_kernel)
    """
    result = extract_ir(kernel)
    return result['python_source'], result['cpp_kernel']
