module @jit_scan_kernel attributes {mhlo.num_partitions = 1 : i32, mhlo.num_replicas = 1 : i32} {
  func.func public @main(%arg0: tensor<100xf32>) -> (tensor<100xf32> {jax.result_info = "result"}) {
    %cst = stablehlo.constant dense<0.000000e+00> : tensor<f32>
    %cst_0 = stablehlo.constant dense<0.000000e+00> : tensor<f32>
    %0 = stablehlo.broadcast_in_dim %cst_0, dims = [] : (tensor<f32>) -> tensor<100xf32>
    %c = stablehlo.constant dense<0> : tensor<i32>
    %1:4 = stablehlo.while(%iterArg = %arg0, %iterArg_1 = %c, %iterArg_2 = %cst, %iterArg_3 = %0) : tensor<100xf32>, tensor<i32>, tensor<f32>, tensor<100xf32>
    cond {
      %c_4 = stablehlo.constant dense<100> : tensor<i32>
      %2 = stablehlo.compare  LT, %iterArg_1, %c_4,  SIGNED : (tensor<i32>, tensor<i32>) -> tensor<i1>
      stablehlo.return %2 : tensor<i1>
    } do {
      %2 = stablehlo.dynamic_slice %iterArg, %iterArg_1, sizes = [1] : (tensor<100xf32>, tensor<i32>) -> tensor<1xf32>
      %3 = stablehlo.reshape %2 : (tensor<1xf32>) -> tensor<f32>
      %4:2 = func.call @closed_call(%iterArg_2, %3) : (tensor<f32>, tensor<f32>) -> (tensor<f32>, tensor<f32>)
      %5 = stablehlo.broadcast_in_dim %4#1, dims = [] : (tensor<f32>) -> tensor<1xf32>
      %6 = stablehlo.dynamic_update_slice %iterArg_3, %5, %iterArg_1 : (tensor<100xf32>, tensor<1xf32>, tensor<i32>) -> tensor<100xf32>
      %c_4 = stablehlo.constant dense<1> : tensor<i32>
      %7 = stablehlo.add %iterArg_1, %c_4 : tensor<i32>
      stablehlo.return %iterArg, %7, %4#0, %6 : tensor<100xf32>, tensor<i32>, tensor<f32>, tensor<100xf32>
    }
    return %1#3 : tensor<100xf32>
  }
  func.func private @closed_call(%arg0: tensor<f32>, %arg1: tensor<f32>) -> (tensor<f32>, tensor<f32>) {
    %0 = stablehlo.convert %arg0 : tensor<f32>
    %1 = stablehlo.add %0, %arg1 : tensor<f32>
    return %1, %1 : tensor<f32>, tensor<f32>
  }
}
