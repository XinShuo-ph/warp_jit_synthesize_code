module @jit_loop_kernel attributes {mhlo.num_partitions = 1 : i32, mhlo.num_replicas = 1 : i32} {
  func.func public @main(%arg0: tensor<100xf32>) -> (tensor<f32> {jax.result_info = "result"}) {
    %c = stablehlo.constant dense<0> : tensor<i32>
    %cst = stablehlo.constant dense<0.000000e+00> : tensor<f32>
    %c_0 = stablehlo.constant dense<0> : tensor<i32>
    %0:4 = stablehlo.while(%iterArg = %arg0, %iterArg_1 = %c_0, %iterArg_2 = %c, %iterArg_3 = %cst) : tensor<100xf32>, tensor<i32>, tensor<i32>, tensor<f32>
    cond {
      %c_4 = stablehlo.constant dense<100> : tensor<i32>
      %1 = stablehlo.compare  LT, %iterArg_1, %c_4,  SIGNED : (tensor<i32>, tensor<i32>) -> tensor<i1>
      stablehlo.return %1 : tensor<i1>
    } do {
      %1:2 = func.call @closed_call(%iterArg, %iterArg_2, %iterArg_3) : (tensor<100xf32>, tensor<i32>, tensor<f32>) -> (tensor<i32>, tensor<f32>)
      %c_4 = stablehlo.constant dense<1> : tensor<i32>
      %2 = stablehlo.add %iterArg_1, %c_4 : tensor<i32>
      stablehlo.return %iterArg, %2, %1#0, %1#1 : tensor<100xf32>, tensor<i32>, tensor<i32>, tensor<f32>
    }
    return %0#3 : tensor<f32>
  }
  func.func private @closed_call(%arg0: tensor<100xf32>, %arg1: tensor<i32>, %arg2: tensor<f32>) -> (tensor<i32>, tensor<f32>) {
    %c = stablehlo.constant dense<1> : tensor<i32>
    %0 = stablehlo.add %arg1, %c : tensor<i32>
    %c_0 = stablehlo.constant dense<0> : tensor<i32>
    %1 = stablehlo.compare  LT, %arg1, %c_0,  SIGNED : (tensor<i32>, tensor<i32>) -> tensor<i1>
    %2 = stablehlo.convert %arg1 : tensor<i32>
    %c_1 = stablehlo.constant dense<100> : tensor<i32>
    %3 = stablehlo.add %2, %c_1 : tensor<i32>
    %4 = stablehlo.select %1, %3, %arg1 : tensor<i1>, tensor<i32>
    %5 = stablehlo.dynamic_slice %arg0, %4, sizes = [1] : (tensor<100xf32>, tensor<i32>) -> tensor<1xf32>
    %6 = stablehlo.reshape %5 : (tensor<1xf32>) -> tensor<f32>
    %7 = stablehlo.convert %arg2 : tensor<f32>
    %8 = stablehlo.add %7, %6 : tensor<f32>
    return %0, %8 : tensor<i32>, tensor<f32>
  }
}
